---
title: "Pointers"
description: "Understand pointers in Go — memory addresses, dereferencing, and when to use them."
order: 9
---

## What is a Pointer?

A pointer is a variable that stores the **memory address** of another variable. Instead of holding a value like `42` or `"hello"`, a pointer holds the location in memory where that value lives.

Think of memory like a grid of numbered boxes. A regular variable holds a value in one box. A pointer holds the **number of the box** where the value is stored.

---

## The Two Pointer Operators

Go uses two operators for pointers:

- **`&`** (address-of) — gets the memory address of a variable
- **`*`** (dereference) — gets the value stored at a memory address

```gorun
// pointer-basics.go
package main

import "fmt"

func main() {
    x := 42

    // & gets the address of x
    p := &x
    fmt.Println("Value of x:", x)   // 42
    fmt.Println("Address of x:", p) // something like 0xc0000b4008
    fmt.Printf("Type of p: %T\n", p) // *int

    // * dereferences — reads the value at the address
    fmt.Println("Value via pointer:", *p) // 42

    // * on the left side — WRITES to the address
    *p = 100
    fmt.Println("x after *p = 100:", x) // 100 — x was changed!
}
```

When you write through a pointer (`*p = 100`), you're changing the original variable — not a copy.

---

## Pointers vs Values — The Key Difference

Without a pointer, Go **copies** the value when passing to a function. The original is untouched:

```gorun
// value-vs-pointer.go
package main

import "fmt"

// Takes a copy — original is unchanged
func doubleValue(n int) {
    n = n * 2
    fmt.Println("Inside doubleValue:", n) // 20
}

// Takes a pointer — original IS changed
func doublePointer(n *int) {
    *n = *n * 2
    fmt.Println("Inside doublePointer:", *n) // 20
}

func main() {
    a := 10
    doubleValue(a)
    fmt.Println("After doubleValue:", a) // Still 10 — copy was modified

    b := 10
    doublePointer(&b)
    fmt.Println("After doublePointer:", b) // 20 — original was modified
}
```

This is the core reason to use pointers: **to let a function modify the caller's variable**.

---

## Creating Pointers with `new()`

The `new()` built-in allocates memory for a type, zeroes it, and returns a pointer:

```gorun
// new-pointer.go
package main

import "fmt"

func main() {
    // new(int) allocates an int, sets it to 0, returns *int
    p := new(int)
    fmt.Println("Default value:", *p) // 0

    *p = 42
    fmt.Println("After assignment:", *p) // 42

    // new(string)
    s := new(string)
    *s = "hello"
    fmt.Println("String pointer:", *s) // hello

    // In practice, you'll use & more often than new()
    x := 100
    px := &x // same as new(int) + *px = 100
    fmt.Println(*px) // 100
}
```

---

## Nil Pointers

An uninitialized pointer has value `nil` — it points to nothing. Dereferencing a nil pointer causes a **panic** (runtime crash):

```gorun
// nil-pointer.go
package main

import "fmt"

func main() {
    var p *int // p is nil
    fmt.Println("p is nil:", p == nil) // true

    // Always check for nil before dereferencing
    if p != nil {
        fmt.Println("Value:", *p)
    } else {
        fmt.Println("Pointer is nil — nothing to read")
    }

    // Initialize it before use
    x := 42
    p = &x
    fmt.Println("Now p is:", *p) // 42
}
```

---

## Pointers with Structs

Pointers to structs are very common in Go. The `.` operator works on struct pointers directly — no need to write `(*p).Field`:

```gorun
// struct-pointers.go
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

func birthday(p *Person) {
    p.Age++ // shorthand for (*p).Age++
}

func main() {
    alice := Person{Name: "Alice", Age: 30}

    // & creates a pointer to alice
    p := &alice
    fmt.Println("Name:", p.Name) // Alice — dot works on pointers too
    fmt.Println("Age:", p.Age)   // 30

    birthday(&alice)
    fmt.Println("After birthday:", alice.Age) // 31

    // Create a struct directly as a pointer with &
    bob := &Person{Name: "Bob", Age: 25}
    birthday(bob)
    fmt.Println("Bob's age:", bob.Age) // 26
}
```

---

## When to Use Pointers

Use pointers when you want to:

1. **Modify** a variable inside a function
2. **Avoid copying** large data structures (performance)
3. Represent an **optional** value (pointer can be `nil`, value can't)

```gorun
// when-to-use-pointers.go
package main

import "fmt"

// Large struct — pass as pointer to avoid copying
type Config struct {
    Host     string
    Port     int
    Debug    bool
    MaxConns int
}

func applyDefaults(cfg *Config) {
    if cfg.Host == "" {
        cfg.Host = "localhost"
    }
    if cfg.Port == 0 {
        cfg.Port = 8080
    }
    if cfg.MaxConns == 0 {
        cfg.MaxConns = 100
    }
}

// Optional value — pointer can be nil to mean "not set"
func greet(nickname *string) {
    if nickname == nil {
        fmt.Println("Hello, stranger!")
    } else {
        fmt.Printf("Hello, %s!\n", *nickname)
    }
}

func main() {
    cfg := &Config{Debug: true}
    applyDefaults(cfg)
    fmt.Printf("Host: %s, Port: %d, MaxConns: %d\n",
        cfg.Host, cfg.Port, cfg.MaxConns)

    greet(nil)
    name := "Gopher"
    greet(&name)
}
```

---

<ChallengeBlock
  title="Swap with Pointers"
  description="Write a function swap(a, b *int) that swaps the values of two integers using pointers. Verify it works by printing the values before and after calling swap."
  hint="Dereference the pointers with * to read/write the values: tmp := *a; *a = *b; *b = tmp"
  starter={`package main

import "fmt"

func swap(a, b *int) {
\t// TODO: swap the values that a and b point to
}

func main() {
\tx, y := 10, 20
\tfmt.Println("Before:", x, y) // 10 20
\tswap(&x, &y)
\tfmt.Println("After:", x, y)  // 20 10
}`}
/>

## What's Next?

Now that you understand pointers, let's learn about **structs** — Go's way to create custom data types by grouping related fields together.
