---
title: "Maps"
description: "Learn to use Go's maps for key-value storage, lookups, and data organization."
order: 7
---

## What is a Map?

A map is a collection of **key-value pairs** — like a dictionary in Python, a HashMap in Java, or an object in JavaScript. Maps let you store data and look it up quickly by a unique key.

```gorun
// map-intro.go
package main

import "fmt"

func main() {
    // Create a map: key type is string, value type is int
    ages := map[string]int{
        "Alice":   30,
        "Bob":     25,
        "Charlie": 35,
    }

    fmt.Println("Ages:", ages)
    fmt.Println("Alice's age:", ages["Alice"])
    fmt.Println("Bob's age:", ages["Bob"])
}
```

The syntax is `map[KeyType]ValueType`. Keys must be a comparable type (strings, numbers, booleans), and values can be any type.

---

## Creating Maps

There are several ways to create a map:

```gorun
// map-create.go
package main

import "fmt"

func main() {
    // Method 1: Map literal (most common)
    colors := map[string]string{
        "red":   "#FF0000",
        "green": "#00FF00",
        "blue":  "#0000FF",
    }
    fmt.Println("Colors:", colors)

    // Method 2: make() — creates an empty map
    scores := make(map[string]int)
    fmt.Println("Empty scores:", scores)
    fmt.Println("Length:", len(scores))

    // Method 3: var declaration (nil map — can read but can't write!)
    var config map[string]string
    fmt.Println("Config is nil:", config == nil)
    // config["key"] = "value" // PANIC! Can't write to nil map

    // Always use make() or a literal to create a writable map
    config = make(map[string]string)
    config["key"] = "value" // This works
    fmt.Println("Config:", config)
}
```

> **Careful:** A `var m map[string]int` creates a `nil` map. You can read from it (returns zero value), but writing to it will cause a runtime panic. Always initialize with `make()` or a literal.

---

## Adding and Updating Keys

```gorun
// map-add-update.go
package main

import "fmt"

func main() {
    inventory := make(map[string]int)

    // Add new keys
    inventory["apples"] = 10
    inventory["bananas"] = 5
    inventory["oranges"] = 8
    fmt.Println("Inventory:", inventory)

    // Update an existing key
    inventory["apples"] = 15
    fmt.Println("After update:", inventory)

    // Increment a value
    inventory["bananas"] += 3
    fmt.Println("After increment:", inventory)

    // The zero value for int is 0, so this works even for new keys
    inventory["grapes"] += 1 // creates "grapes" with value 0, then adds 1
    fmt.Println("After new key increment:", inventory)
}
```

---

## Reading Values and Checking if a Key Exists

When you access a key that doesn't exist, Go returns the **zero value** for that type. Use the two-value form to check if a key actually exists:

```gorun
// map-read-check.go
package main

import "fmt"

func main() {
    ages := map[string]int{
        "Alice": 30,
        "Bob":   25,
    }

    // Simple read — returns zero value if key doesn't exist
    fmt.Println("Alice:", ages["Alice"])   // 30
    fmt.Println("Unknown:", ages["Zara"])  // 0 (zero value for int)

    // Two-value form: value, ok
    // 'ok' is true if the key exists, false if it doesn't
    age, ok := ages["Alice"]
    fmt.Printf("Alice: age=%d, exists=%t\n", age, ok)

    age, ok = ages["Zara"]
    fmt.Printf("Zara: age=%d, exists=%t\n", age, ok)

    // Common pattern: check before using
    if age, ok := ages["Bob"]; ok {
        fmt.Println("Bob's age is", age)
    } else {
        fmt.Println("Bob not found")
    }

    if _, ok := ages["David"]; !ok {
        fmt.Println("David is not in the map")
    }
}
```

The `value, ok := myMap[key]` pattern is one of the most important Go idioms. The `ok` variable tells you definitively whether the key exists.

---

## Deleting Keys

Use the built-in `delete()` function. It's safe to call even if the key doesn't exist:

```gorun
// map-delete.go
package main

import "fmt"

func main() {
    fruits := map[string]int{
        "apple":  5,
        "banana": 3,
        "cherry": 8,
        "date":   2,
    }
    fmt.Println("Before:", fruits)

    // Delete a key
    delete(fruits, "banana")
    fmt.Println("After delete:", fruits)

    // Deleting a non-existent key is safe (no error)
    delete(fruits, "mango")
    fmt.Println("After no-op delete:", fruits)

    fmt.Println("Length:", len(fruits))
}
```

---

## Iterating Over Maps

Use `range` to loop through all key-value pairs:

```gorun
// map-iterate.go
package main

import (
    "fmt"
    "sort"
)

func main() {
    population := map[string]int{
        "Tokyo":     14000000,
        "Delhi":     11000000,
        "Shanghai":  24000000,
        "São Paulo": 12000000,
        "Mumbai":    20000000,
    }

    // Iterate (order is random!)
    fmt.Println("=== Random order ===")
    for city, pop := range population {
        fmt.Printf("%-12s %d\n", city, pop)
    }

    // For sorted output, sort the keys first
    fmt.Println("\n=== Sorted by city name ===")
    cities := make([]string, 0, len(population))
    for city := range population {
        cities = append(cities, city)
    }
    sort.Strings(cities)

    for _, city := range cities {
        fmt.Printf("%-12s %d\n", city, population[city])
    }
}
```

> **Remember:** Map iteration order is **not guaranteed** in Go. If you need consistent ordering, sort the keys first.

---

## Maps with Complex Values

Map values can be any type — slices, other maps, or even structs:

```gorun
// map-complex-values.go
package main

import "fmt"

func main() {
    // Map of string to slice of strings
    hobbies := map[string][]string{
        "Alice": {"reading", "hiking", "coding"},
        "Bob":   {"gaming", "cooking"},
    }

    // Add a hobby
    hobbies["Alice"] = append(hobbies["Alice"], "painting")
    hobbies["Charlie"] = []string{"music"}

    for person, activities := range hobbies {
        fmt.Printf("%s: %v\n", person, activities)
    }

    // Nested maps: map of maps
    school := map[string]map[string]int{
        "math":    {"Alice": 95, "Bob": 87},
        "science": {"Alice": 90, "Bob": 92},
    }

    fmt.Println("\nMath scores:", school["math"])
    fmt.Println("Alice's science score:", school["science"]["Alice"])
}
```

---

## Counting and Grouping with Maps

Maps are perfect for counting occurrences and grouping data:

```gorun
// map-counting.go
package main

import "fmt"

func main() {
    // Word frequency counter
    words := []string{"go", "is", "awesome", "go", "is", "fast", "go", "is", "simple"}

    frequency := make(map[string]int)
    for _, word := range words {
        frequency[word]++ // zero value for int is 0, so this works perfectly
    }

    fmt.Println("Word frequencies:")
    for word, count := range frequency {
        fmt.Printf("  %-10s %d\n", word, count)
    }

    // Group by first letter
    names := []string{"Alice", "Bob", "Charlie", "Anna", "Brian", "Carol"}
    groups := make(map[byte][]string)
    for _, name := range names {
        firstLetter := name[0]
        groups[firstLetter] = append(groups[firstLetter], name)
    }

    fmt.Println("\nGrouped by first letter:")
    for letter, group := range groups {
        fmt.Printf("  %c: %v\n", letter, group)
    }
}
```

---

## Practical Example: Simple Phone Book

```gorun
// phonebook.go
package main

import "fmt"

func main() {
    phonebook := make(map[string]string)

    // Add contacts
    phonebook["Alice"] = "555-0001"
    phonebook["Bob"] = "555-0002"
    phonebook["Charlie"] = "555-0003"

    // Look up a contact
    lookup := "Bob"
    if number, ok := phonebook[lookup]; ok {
        fmt.Printf("%s: %s\n", lookup, number)
    } else {
        fmt.Printf("%s not found\n", lookup)
    }

    // Update a contact
    phonebook["Alice"] = "555-9999"

    // Delete a contact
    delete(phonebook, "Charlie")

    // List all contacts
    fmt.Println("\nAll contacts:")
    for name, number := range phonebook {
        fmt.Printf("  %s → %s\n", name, number)
    }

    fmt.Printf("\nTotal contacts: %d\n", len(phonebook))
}
```

---

<ChallengeBlock
  title="Word Frequency Counter"
  description="Count how many times each word appears in the sentence below and print each word with its count. Use a map[string]int to store the counts."
  hint="Split the sentence by spaces with strings.Fields(), then loop over the words and increment the map entry for each one."
  starter={`package main

import (
\t"fmt"
\t"strings"
)

func main() {
\tsentence := "the quick brown fox jumps over the lazy dog the fox"
\tcounts := make(map[string]int)

\t// TODO: count each word in sentence
\tfor _, word := range strings.Fields(sentence) {
\t\t_ = word // remove this and implement
\t}

\t// print each word and its count
\tfor word, count := range counts {
\t\tfmt.Printf("%s: %d\n", word, count)
\t}
}`}
/>

## What's Next?

You now have Go's core data structures down! Next, let's dive into **functions** — defining them, returning multiple values, closures, and defer.
