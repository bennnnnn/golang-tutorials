---
title: "Testing in Go"
description: "Learn how to write tests, table-driven tests, and benchmarks to ensure your Go code is correct and fast."
order: 16
difficulty: "intermediate"
estimatedMinutes: 18
---

## Why Test?

Tests are the safety net that lets you change code confidently. Go has a built-in testing framework in the `testing` package — no third-party library needed. You write test functions, run `go test`, and Go tells you what passed and what failed.

**Benefits of testing:**
- Catch bugs before they reach users
- Safely refactor code without breaking things
- Document expected behavior through examples
- Enable continuous integration / deployment pipelines

---

## The `testing` Package

Go's `testing` package provides the tools every test needs. The key type is `testing.T`, which you use to report failures and log information.

**Core methods on `*testing.T`:**
- `t.Errorf(format, args...)` — marks test as failed and logs a message, but continues running
- `t.Fatalf(format, args...)` — marks test as failed, logs a message, and stops the test immediately
- `t.Logf(format, args...)` — logs information (only shown on failure)
- `t.Helper()` — marks a function as a test helper (better error locations)

---

## Simulating Tests in the Playground

Normally you run tests with `go test ./...`. Since the Go Playground only runs `main()`, we simulate the testing framework by calling our test functions from `main` and printing `PASS` or `FAIL`. The logic is identical — only the runner changes.

```gorun
// test-simulation.go
package main

import "fmt"

func add(a, b int) int {
    return a + b
}

// Simulated test — in real projects this lives in add_test.go
func testAdd() {
    result := add(2, 3)
    if result != 5 {
        fmt.Printf("FAIL: add(2, 3) = %d, want 5\n", result)
        return
    }
    fmt.Println("PASS: add(2, 3) = 5")

    result2 := add(-1, 1)
    if result2 != 0 {
        fmt.Printf("FAIL: add(-1, 1) = %d, want 0\n", result2)
        return
    }
    fmt.Println("PASS: add(-1, 1) = 0")
}

func main() {
    testAdd()
}
```

---

## Table-Driven Tests

The most common Go testing pattern is the **table-driven test**: define a slice of test cases (input + expected output), then loop over them. This eliminates repetitive code and makes it easy to add new cases.

```gorun
// table-driven.go
package main

import "fmt"

func multiply(a, b int) int {
    return a * b
}

func testMultiply() {
    cases := []struct {
        a, b int
        want int
    }{
        {2, 3, 6},
        {0, 5, 0},
        {-1, 4, -4},
        {7, 7, 49},
    }

    for _, tc := range cases {
        got := multiply(tc.a, tc.b)
        if got != tc.want {
            fmt.Printf("FAIL: multiply(%d, %d) = %d, want %d\n", tc.a, tc.b, got, tc.want)
        } else {
            fmt.Printf("PASS: multiply(%d, %d) = %d\n", tc.a, tc.b, got)
        }
    }
}

func main() {
    testMultiply()
}
```

---

## Test Helpers

When multiple tests share setup or assertion logic, extract it into a **helper function**. In real `go test`, calling `t.Helper()` inside the helper ensures error messages point to the calling line — not inside the helper itself.

```gorun
// test-helpers.go
package main

import "fmt"

func divide(a, b float64) (float64, bool) {
    if b == 0 {
        return 0, false // division by zero — signal error
    }
    return a / b, true
}

// assertEqual is a reusable test helper
func assertEqual(label string, got, want float64) bool {
    if got != want {
        fmt.Printf("FAIL [%s]: got %.2f, want %.2f\n", label, got, want)
        return false
    }
    fmt.Printf("PASS [%s]: got %.2f\n", label, got)
    return true
}

func testDivide() {
    result, ok := divide(10, 2)
    if !ok {
        fmt.Println("FAIL: unexpected division error for 10/2")
        return
    }
    assertEqual("10/2", result, 5.0)

    _, ok = divide(5, 0)
    if ok {
        fmt.Println("FAIL: expected error for division by zero")
    } else {
        fmt.Println("PASS: divide by zero correctly rejected")
    }
}

func main() {
    testDivide()
}
```

---

## Benchmarks — Measuring Performance

In real Go projects, benchmark functions are named `BenchmarkXxx(b *testing.B)` and run via `go test -bench=.`. The framework calls your code `b.N` times and measures the average. Here we simulate the concept by timing a function ourselves.

```gorun
// benchmark-concept.go
package main

import (
    "fmt"
    "strings"
    "time"
)

// Two ways to build a repeated string — which is faster?
func buildWithPlus(n int) string {
    result := ""
    for i := 0; i < n; i++ {
        result += "x"
    }
    return result
}

func buildWithBuilder(n int) string {
    var sb strings.Builder
    for i := 0; i < n; i++ {
        sb.WriteByte('x')
    }
    return sb.String()
}

func timeit(name string, n int, fn func(int) string) {
    start := time.Now()
    for i := 0; i < 1000; i++ {
        fn(n)
    }
    elapsed := time.Since(start)
    fmt.Printf("%-20s 1000 iterations: %v\n", name, elapsed)
}

func main() {
    fmt.Println("Benchmark: building a 200-character string 1000 times")
    timeit("string + concat", 200, buildWithPlus)
    timeit("strings.Builder", 200, buildWithBuilder)
    fmt.Println("strings.Builder wins for repeated concatenation!")
}
```

---

## Multiple Edge Cases

Real functions need to handle boundary conditions: empty inputs, zero values, negative numbers, very large inputs. Good tests cover all of these.

```gorun
// edge-cases.go
package main

import "fmt"

func clamp(val, min, max int) int {
    if val < min {
        return min
    }
    if val > max {
        return max
    }
    return val
}

func testClamp() {
    cases := []struct {
        val, min, max int
        want          int
        label         string
    }{
        {5, 0, 10, 5, "in range"},
        {-3, 0, 10, 0, "below min"},
        {15, 0, 10, 10, "above max"},
        {0, 0, 10, 0, "at min boundary"},
        {10, 0, 10, 10, "at max boundary"},
        {5, 5, 5, 5, "min == max"},
    }

    passed, failed := 0, 0
    for _, tc := range cases {
        got := clamp(tc.val, tc.min, tc.max)
        if got != tc.want {
            fmt.Printf("FAIL [%s]: clamp(%d, %d, %d) = %d, want %d\n",
                tc.label, tc.val, tc.min, tc.max, got, tc.want)
            failed++
        } else {
            fmt.Printf("PASS [%s]\n", tc.label)
            passed++
        }
    }
    fmt.Printf("\n%d passed, %d failed\n", passed, failed)
}

func main() {
    testClamp()
}
```

---

<ChallengeBlock
  title="Test an isPalindrome Function"
  description="A palindrome reads the same forwards and backwards (e.g. 'racecar'). Implement isPalindrome(s string) bool, then write a table-driven test covering at least 4 cases: a true palindrome, a false case, an empty string (palindrome), and a single character (palindrome). Print PASS or FAIL for each."
  hint="Reverse the string by ranging over it and building a new one, or compare characters from both ends. Your table should include cases like 'racecar' (true), 'hello' (false), '' (true), and 'a' (true)."
  starter={`package main

import "fmt"

func isPalindrome(s string) bool {
	// TODO: return true if s reads the same forwards and backwards
	return false
}

func main() {
	cases := []struct {
		input string
		want  bool
	}{
		// TODO: add at least 4 test cases
	}

	for _, tc := range cases {
		got := isPalindrome(tc.input)
		if got != tc.want {
			fmt.Printf("FAIL: isPalindrome(%q) = %v, want %v\n", tc.input, got, tc.want)
		} else {
			fmt.Printf("PASS: isPalindrome(%q) = %v\n", tc.input, got)
		}
	}
}`}
/>

## What's Next?

You now know how to structure tests, use table-driven patterns, write helper functions, and think about benchmarking. Next we'll look at **HTTP handlers** — building the web layer of Go applications.
