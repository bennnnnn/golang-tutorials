---
title: "Arrays & Slices"
description: "Understand fixed-size arrays and dynamic slices — Go's primary tools for ordered collections."
order: 6
---

## Arrays vs Slices

Go has two ways to store ordered collections: **arrays** (fixed size) and **slices** (dynamic size). In practice, you'll use slices 99% of the time, but understanding arrays first helps explain how slices work under the hood.

---

## Arrays — Fixed Size

An array has a **fixed length** set at creation time. The length is part of the type — `[3]int` and `[5]int` are different types:

```gorun
// arrays.go
package main

import "fmt"

func main() {
    // Declare an array of 5 integers (all zero by default)
    var numbers [5]int
    fmt.Println("Default:", numbers) // [0 0 0 0 0]

    // Set values by index
    numbers[0] = 10
    numbers[1] = 20
    numbers[4] = 50
    fmt.Println("Modified:", numbers) // [10 20 0 0 50]

    // Declare and initialize in one line
    fruits := [3]string{"apple", "banana", "cherry"}
    fmt.Println("Fruits:", fruits)

    // Let Go count the elements with [...]
    colors := [...]string{"red", "green", "blue", "yellow"}
    fmt.Println("Colors:", colors)
    fmt.Println("Length:", len(colors)) // 4

    // Access individual elements
    fmt.Println("First fruit:", fruits[0])
    fmt.Println("Last color:", colors[len(colors)-1])
}
```

**Array limitations:**
- Size is fixed at compile time — you can't add or remove elements
- `[3]int` and `[5]int` are **different types** — you can't assign one to the other
- Arrays are **copied** when passed to functions (not referenced)

---

## Slices — Dynamic Collections

Slices are Go's answer to dynamic arrays. They're flexible, powerful, and what you'll use in almost every Go program:

```gorun
// slices-basic.go
package main

import "fmt"

func main() {
    // Create a slice with initial values
    fruits := []string{"apple", "banana", "cherry"}
    fmt.Println("Fruits:", fruits)
    fmt.Println("Length:", len(fruits))

    // Create an empty slice
    var numbers []int
    fmt.Println("Empty slice:", numbers)
    fmt.Println("Is nil?", numbers == nil) // true — uninitialized slice

    // Create with make (specify length and optional capacity)
    scores := make([]int, 3)      // length 3, capacity 3
    fmt.Println("Scores:", scores) // [0 0 0]

    buffer := make([]int, 0, 10)      // length 0, capacity 10
    fmt.Println("Buffer length:", len(buffer))
    fmt.Println("Buffer capacity:", cap(buffer))
}
```

> **Key difference:** Arrays use `[N]Type`, slices use `[]Type` (no number between brackets).

---

## `len()` and `cap()` — Length vs Capacity

Every slice has two properties:
- **Length** (`len`) — how many elements it currently holds
- **Capacity** (`cap`) — how many elements it can hold before needing to allocate more memory

```gorun
// len-cap.go
package main

import "fmt"

func main() {
    s := make([]int, 3, 10) // length 3, capacity 10
    fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)

    // Adding elements within capacity is fast (no reallocation)
    s = append(s, 42)
    fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)

    // When capacity is exceeded, Go allocates a new, larger array
    big := make([]int, 0, 2)
    for i := 0; i < 5; i++ {
        big = append(big, i)
        fmt.Printf("len=%d cap=%d %v\n", len(big), cap(big), big)
    }
}
```

Go typically doubles the capacity when it needs to grow, so appending is efficient on average.

---

## `append()` — Adding Elements

`append` is the primary way to add elements to a slice. It returns a **new slice** (the original is unchanged):

```gorun
// append.go
package main

import "fmt"

func main() {
    fruits := []string{"apple", "banana"}

    // Append one element
    fruits = append(fruits, "cherry")
    fmt.Println(fruits) // [apple banana cherry]

    // Append multiple elements
    fruits = append(fruits, "date", "elderberry")
    fmt.Println(fruits) // [apple banana cherry date elderberry]

    // Append one slice to another using ...
    moreFruits := []string{"fig", "grape"}
    fruits = append(fruits, moreFruits...)
    fmt.Println(fruits)

    // Build a slice from scratch
    var numbers []int
    for i := 1; i <= 5; i++ {
        numbers = append(numbers, i)
    }
    fmt.Println("Numbers:", numbers)
}
```

> **Important:** Always reassign the result: `s = append(s, value)`. The `append` function may return a new slice if it needed to allocate more memory.

---

## Slicing — Creating Sub-Slices

Use `slice[low:high]` to create a new slice from a portion of an existing one:

```gorun
// slicing.go
package main

import "fmt"

func main() {
    numbers := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

    // slice[low:high] — includes low, excludes high
    fmt.Println(numbers[2:5])  // [2 3 4]
    fmt.Println(numbers[:3])   // [0 1 2]     (from start)
    fmt.Println(numbers[7:])   // [7 8 9]     (to end)
    fmt.Println(numbers[:])    // [0 1 2 ... 9] (full copy reference)

    // Slicing a string works the same way
    greeting := "Hello, World!"
    fmt.Println(greeting[0:5])  // Hello
    fmt.Println(greeting[7:])   // World!
}
```

> **Warning:** Sub-slices share the same underlying array as the original. Modifying one can affect the other. Use `copy()` if you need an independent copy.

---

## `copy()` — Copying Slices

```gorun
// copy-slice.go
package main

import "fmt"

func main() {
    original := []int{1, 2, 3, 4, 5}

    // Create an independent copy
    duplicate := make([]int, len(original))
    copied := copy(duplicate, original)
    fmt.Printf("Copied %d elements: %v\n", copied, duplicate)

    // Modify the copy — original is unaffected
    duplicate[0] = 999
    fmt.Println("Original:", original)   // [1 2 3 4 5]
    fmt.Println("Duplicate:", duplicate) // [999 2 3 4 5]

    // Partial copy
    partial := make([]int, 3)
    copy(partial, original)
    fmt.Println("Partial:", partial) // [1 2 3]
}
```

---

## Removing Elements from a Slice

Go doesn't have a built-in `remove` function. Instead, use slicing and `append`:

```gorun
// remove-element.go
package main

import "fmt"

func main() {
    fruits := []string{"apple", "banana", "cherry", "date", "elderberry"}

    // Remove element at index 2 ("cherry")
    indexToRemove := 2
    fruits = append(fruits[:indexToRemove], fruits[indexToRemove+1:]...)
    fmt.Println("After removing index 2:", fruits)

    // Remove first element
    fruits = fruits[1:]
    fmt.Println("After removing first:", fruits)

    // Remove last element
    fruits = fruits[:len(fruits)-1]
    fmt.Println("After removing last:", fruits)
}
```

---

## Common Slice Patterns

```gorun
// slice-patterns.go
package main

import (
    "fmt"
    "sort"
)

func main() {
    // Check if a slice contains a value
    numbers := []int{3, 1, 4, 1, 5, 9, 2, 6}
    target := 5
    found := false
    for _, n := range numbers {
        if n == target {
            found = true
            break
        }
    }
    fmt.Printf("Contains %d: %t\n", target, found)

    // Sort a slice
    sort.Ints(numbers)
    fmt.Println("Sorted:", numbers)

    // Reverse a slice
    for i, j := 0, len(numbers)-1; i < j; i, j = i+1, j-1 {
        numbers[i], numbers[j] = numbers[j], numbers[i]
    }
    fmt.Println("Reversed:", numbers)

    // Filter: keep only even numbers
    all := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    var evens []int
    for _, n := range all {
        if n%2 == 0 {
            evens = append(evens, n)
        }
    }
    fmt.Println("Evens:", evens)

    // Sum all elements
    sum := 0
    for _, n := range all {
        sum += n
    }
    fmt.Println("Sum:", sum)
}
```

---

## Multi-Dimensional Slices

Slices of slices — useful for grids, matrices, and tables:

```gorun
// multi-dimensional.go
package main

import "fmt"

func main() {
    // Create a 3x3 grid
    grid := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }

    // Access elements
    fmt.Println("Center:", grid[1][1]) // 5

    // Iterate
    for i, row := range grid {
        for j, val := range row {
            fmt.Printf("[%d][%d]=%d  ", i, j, val)
        }
        fmt.Println()
    }
}
```

---

<ChallengeBlock
  title="Reverse a Slice"
  description="Write a function called reverse that takes a []int and reverses its elements in place (without creating a new slice). Then call it and print the result."
  hint="Swap elements from the outside in using two indices: one starting at 0 and one at len(s)-1, moving toward the middle."
  starter={`package main

import "fmt"

func reverse(s []int) {
\t// TODO: reverse the slice in place
}

func main() {
\tnums := []int{1, 2, 3, 4, 5}
\treverse(nums)
\tfmt.Println(nums) // should print [5 4 3 2 1]
}`}
/>

## What's Next?

Now you can work with ordered collections! Next, let's learn about **maps** — Go's key-value data structure for fast lookups.
