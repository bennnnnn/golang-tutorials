---
title: "Structs"
description: "Create custom types in Go by grouping related data together with structs."
order: 10
difficulty: "intermediate"
estimatedMinutes: 15
---

## What is a Struct?

A struct is a custom data type that groups related fields under one name. It's Go's way to model real-world objects — a `User` has a name and email, a `Rectangle` has width and height, a `Product` has a name and price.

---

## Defining a Struct

Use the `type` keyword and `struct` to define a new type:

```gorun
// define-struct.go
package main

import "fmt"

// Define a struct type
type Person struct {
    Name string
    Age  int
    Email string
}

type Rectangle struct {
    Width  float64
    Height float64
}

func main() {
    // Create a Person using a struct literal
    alice := Person{
        Name:  "Alice",
        Age:   30,
        Email: "alice@example.com",
    }

    fmt.Println("Name:", alice.Name)
    fmt.Println("Age:", alice.Age)
    fmt.Println("Email:", alice.Email)

    rect := Rectangle{Width: 5.0, Height: 3.0}
    fmt.Printf("Rectangle: %.1f x %.1f\n", rect.Width, rect.Height)
}
```

---

## Creating Struct Instances

There are several ways to create a struct:

```gorun
// creating-structs.go
package main

import "fmt"

type Point struct {
    X, Y int // two fields of the same type can be listed together
}

func main() {
    // Method 1: Named fields (recommended — clear and order-independent)
    p1 := Point{X: 10, Y: 20}

    // Method 2: Positional (must match field order — less readable)
    p2 := Point{10, 20}

    // Method 3: Zero-value struct — all fields get their zero values
    var p3 Point // X: 0, Y: 0
    fmt.Println("p3 zero value:", p3)

    // Method 4: Pointer to struct
    p4 := &Point{X: 5, Y: 15}
    fmt.Printf("p4 is a pointer: %T\n", p4) // *main.Point

    // Modify fields with dot notation
    p3.X = 100
    p3.Y = 200
    fmt.Println(p1, p2, p3, *p4)
}
```

---

## Accessing and Modifying Fields

Use `.` (dot notation) to read and write struct fields:

```gorun
// struct-fields.go
package main

import "fmt"

type BankAccount struct {
    Owner   string
    Balance float64
}

func main() {
    account := BankAccount{Owner: "Alice", Balance: 1000.00}

    // Read fields
    fmt.Printf("Owner: %s\n", account.Owner)
    fmt.Printf("Balance: $%.2f\n", account.Balance)

    // Modify fields
    account.Balance += 500.00
    fmt.Printf("After deposit: $%.2f\n", account.Balance)

    account.Balance -= 200.00
    fmt.Printf("After withdrawal: $%.2f\n", account.Balance)

    // Pointer to struct — dot notation still works
    p := &account
    p.Balance += 100.00 // same as (*p).Balance += 100.00
    fmt.Printf("After pointer update: $%.2f\n", account.Balance)
}
```

---

## Structs are Value Types

When you assign a struct to a new variable, Go **copies** it. They're independent:

```gorun
// struct-copy.go
package main

import "fmt"

type Point struct {
    X, Y int
}

func main() {
    original := Point{X: 1, Y: 2}
    copy := original // creates a full copy

    copy.X = 99 // modifying copy doesn't affect original

    fmt.Println("Original:", original) // {1 2}
    fmt.Println("Copy:", copy)         // {99 2}

    // To share data, use a pointer
    shared := &original
    shared.X = 50
    fmt.Println("Original after shared change:", original) // {50 2}
}
```

---

## Nested Structs

Structs can contain other structs:

```gorun
// nested-structs.go
package main

import "fmt"

type Address struct {
    Street string
    City   string
    State  string
}

type Person struct {
    Name    string
    Age     int
    Address Address // nested struct
}

func main() {
    alice := Person{
        Name: "Alice",
        Age:  30,
        Address: Address{
            Street: "123 Main St",
            City:   "Springfield",
            State:  "IL",
        },
    }

    // Access nested fields with chained dots
    fmt.Println("Name:", alice.Name)
    fmt.Println("City:", alice.Address.City)
    fmt.Printf("Address: %s, %s, %s\n",
        alice.Address.Street,
        alice.Address.City,
        alice.Address.State)
}
```

---

## Struct Embedding — Composition Over Inheritance

Go doesn't have inheritance, but it has **embedding** — you can embed one struct inside another without naming the field. The embedded struct's fields are "promoted":

```gorun
// embedding.go
package main

import "fmt"

type Animal struct {
    Name string
}

func (a Animal) Speak() string {
    return a.Name + " makes a sound"
}

type Dog struct {
    Animal       // embedded — no field name!
    Breed string
}

func main() {
    d := Dog{
        Animal: Animal{Name: "Rex"},
        Breed:  "Labrador",
    }

    // Promoted fields — access Animal's fields directly
    fmt.Println("Name:", d.Name)   // same as d.Animal.Name
    fmt.Println("Breed:", d.Breed)

    // Promoted methods — call Animal's methods directly
    fmt.Println(d.Speak()) // Rex makes a sound
}
```

---

## Anonymous Structs

For one-off data groupings, define a struct inline without giving it a name:

```gorun
// anonymous-struct.go
package main

import "fmt"

func main() {
    // Anonymous struct — defined and used in one go
    person := struct {
        Name string
        Age  int
    }{
        Name: "Bob",
        Age:  25,
    }

    fmt.Println(person.Name, person.Age)

    // Useful for grouping test cases or config data
    tests := []struct {
        input    int
        expected int
    }{
        {2, 4},
        {3, 9},
        {4, 16},
    }

    for _, tt := range tests {
        result := tt.input * tt.input
        if result == tt.expected {
            fmt.Printf("%d² = %d ✓\n", tt.input, result)
        }
    }
}
```

---

## Struct Tags

Struct tags are metadata strings attached to fields, commonly used for JSON encoding:

```gorun
// struct-tags.go
package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    Name     string `json:"name"`
    Email    string `json:"email"`
    Password string `json:"-"`        // "-" means skip this field
    Age      int    `json:"age,omitempty"` // omit if zero
}

func main() {
    user := User{
        Name:     "Alice",
        Email:    "alice@example.com",
        Password: "secret123",
        Age:      0, // will be omitted because of omitempty
    }

    // Encode to JSON
    data, _ := json.Marshal(user)
    fmt.Println(string(data))
    // Output: {"name":"Alice","email":"alice@example.com"}
    // Password is skipped, Age is omitted (zero + omitempty)
}
```

---

<ChallengeBlock
  title="Rectangle Calculator"
  description="Define a Rectangle struct with Width and Height fields. Write two functions: Area(r Rectangle) float64 and Perimeter(r Rectangle) float64. Create a rectangle and print both values."
  hint="Area = Width × Height. Perimeter = 2 × (Width + Height)."
  starter={`package main

import "fmt"

type Rectangle struct {
\t// TODO: add Width and Height fields (float64)
}

func Area(r Rectangle) float64 {
\t// TODO: return width * height
\treturn 0
}

func Perimeter(r Rectangle) float64 {
\t// TODO: return 2 * (width + height)
\treturn 0
}

func main() {
\tr := Rectangle{} // TODO: set Width and Height
\tfmt.Printf("Area: %.2f\n", Area(r))
\tfmt.Printf("Perimeter: %.2f\n", Perimeter(r))
}`}
/>

## What's Next?

Now that you can create custom types with structs, let's learn about **methods** — how to attach functions to your struct types.
