---
title: "Functions"
description: "Define functions, use parameters and return values, and master closures and defer."
order: 8
---

## Why Functions?

Functions let you organize your code into reusable blocks. Instead of writing the same logic over and over, you write it once in a function and call it whenever needed.

**Advantages of functions:**
- **Reusability** — write once, use many times
- **Readability** — give meaningful names to blocks of logic
- **Maintainability** — fix a bug in one place, it's fixed everywhere
- **Testability** — test individual pieces of your program

---

## How to Define a Function

Functions are declared with the `func` keyword, followed by the name, parameters, and return type:

```gorun
// define-function.go
package main

import "fmt"

// A simple function with no parameters and no return
func sayHello() {
    fmt.Println("Hello!")
}

// A function with parameters
func greet(name string) {
    fmt.Println("Hello,", name)
}

// A function with a return type
func add(a int, b int) int {
    return a + b
}

// When parameters share a type, you can shorten it
func multiply(a, b int) int {
    return a * b
}

func main() {
    sayHello()              // Hello!
    greet("Gopher")         // Hello, Gopher
    fmt.Println(add(3, 5))  // 8
    fmt.Println(multiply(4, 6)) // 24
}
```

---

## How to Call a Function

Calling a function is simple — use the function name followed by arguments in parentheses:

```gorun
// call-function.go
package main

import "fmt"

func double(n int) int {
    return n * 2
}

func isEven(n int) bool {
    return n%2 == 0
}

func main() {
    // Call and use the result
    result := double(5)
    fmt.Println("Double of 5:", result)

    // Use directly in expressions
    fmt.Println("Double of 10:", double(10))

    // Use in conditions
    if isEven(4) {
        fmt.Println("4 is even")
    }
    if !isEven(7) {
        fmt.Println("7 is odd")
    }
}
```

---

## Return Types and Multiple Returns

Go functions can return **multiple values** — this is one of Go's most distinctive features, especially for error handling:

```gorun
// multiple-returns.go
package main

import (
    "fmt"
    "errors"
    "math"
)

// Return multiple values
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("cannot divide by zero")
    }
    return a / b, nil
}

// Return two values of the same type
func minMax(numbers []int) (int, int) {
    min, max := numbers[0], numbers[0]
    for _, n := range numbers {
        if n < min {
            min = n
        }
        if n > max {
            max = n
        }
    }
    return min, max
}

func main() {
    // Handle the error return
    result, err := divide(10, 3)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Printf("10 / 3 = %.2f\n", result)
    }

    // Error case
    _, err = divide(5, 0)
    fmt.Println("Divide by zero:", err)

    // Multiple returns
    nums := []int{3, 1, 4, 1, 5, 9, 2, 6}
    min, max := minMax(nums)
    fmt.Printf("Min: %d, Max: %d\n", min, max)

    _ = math.Pi // just to use the math import
}
```

---

## Named Return Values

You can name your return values. This serves as documentation and enables "naked" returns:

```gorun
// named-returns.go
package main

import "fmt"

// Named return values act as documentation
func rectangleInfo(width, height float64) (area, perimeter float64) {
    area = width * height
    perimeter = 2 * (width + height)
    return // "naked return" — returns area and perimeter
}

func main() {
    area, perimeter := rectangleInfo(5, 3)
    fmt.Printf("Area: %.1f\n", area)
    fmt.Printf("Perimeter: %.1f\n", perimeter)
}
```

> **Tip:** Use named returns sparingly — they can hurt readability in longer functions.

---

## Variadic Functions (Variable Arguments)

Functions can accept any number of arguments using `...`:

```gorun
// variadic.go
package main

import "fmt"

// Accept any number of integers
func sum(numbers ...int) int {
    total := 0
    for _, n := range numbers {
        total += n
    }
    return total
}

// Mix regular and variadic parameters
func printAll(prefix string, values ...int) {
    for _, v := range values {
        fmt.Printf("%s %d\n", prefix, v)
    }
}

func main() {
    fmt.Println(sum(1, 2, 3))          // 6
    fmt.Println(sum(10, 20, 30, 40))   // 100

    // Pass a slice using ...
    nums := []int{5, 10, 15}
    fmt.Println(sum(nums...))          // 30

    printAll("Number:", 1, 2, 3)
}
```

---

## Functions as Values (First-Class Functions)

In Go, functions are **first-class citizens** — you can assign them to variables and pass them as arguments:

```gorun
// function-values.go
package main

import "fmt"

// A function that takes a function as a parameter
func applyOperation(a, b int, op func(int, int) int) int {
    return op(a, b)
}

func main() {
    // Assign functions to variables
    add := func(a, b int) int { return a + b }
    subtract := func(a, b int) int { return a - b }

    fmt.Println("Add:", applyOperation(10, 3, add))       // 13
    fmt.Println("Subtract:", applyOperation(10, 3, subtract)) // 7

    // Use an anonymous function inline
    result := applyOperation(10, 3, func(a, b int) int {
        return a * b
    })
    fmt.Println("Multiply:", result) // 30
}
```

---

## Closures

A closure is a function that captures variables from its surrounding scope:

```gorun
// closures.go
package main

import "fmt"

// counter returns a function that increments and returns a count
func counter() func() int {
    count := 0
    return func() int {
        count++ // captures 'count' from outer scope
        return count
    }
}

// adder returns a function that adds n to its argument
func adder(n int) func(int) int {
    return func(x int) int {
        return x + n
    }
}

func main() {
    // Each counter has its own independent state
    next := counter()
    fmt.Println(next()) // 1
    fmt.Println(next()) // 2
    fmt.Println(next()) // 3

    // Create specialized functions
    addFive := adder(5)
    addTen := adder(10)
    fmt.Println(addFive(3))  // 8
    fmt.Println(addTen(3))   // 13
}
```

---

## Defer

`defer` schedules a function call to run when the surrounding function returns. It's commonly used for cleanup:

```gorun
// defer.go
package main

import "fmt"

func example() {
    fmt.Println("Start")
    defer fmt.Println("This runs last (deferred)")
    fmt.Println("Middle")
    fmt.Println("End")
}

func multipleDefers() {
    fmt.Println("\n--- Multiple defers (LIFO order) ---")
    defer fmt.Println("First deferred")
    defer fmt.Println("Second deferred")
    defer fmt.Println("Third deferred")
    fmt.Println("Function body")
}

func main() {
    example()
    multipleDefers()
}
```

**Common uses for defer:**
- Closing files: `defer file.Close()`
- Releasing locks: `defer mutex.Unlock()`
- Closing database connections: `defer db.Close()`

---

## Putting It All Together

Here's a practical example combining several function concepts:

```gorun
// practical-example.go
package main

import (
    "fmt"
    "strings"
)

// Transform a slice using a provided function
func mapStrings(items []string, transform func(string) string) []string {
    result := make([]string, len(items))
    for i, item := range items {
        result[i] = transform(item)
    }
    return result
}

// Filter a slice using a provided condition
func filterStrings(items []string, condition func(string) bool) []string {
    var result []string
    for _, item := range items {
        if condition(item) {
            result = append(result, item)
        }
    }
    return result
}

func main() {
    fruits := []string{"apple", "banana", "cherry", "date", "elderberry"}

    // Transform: uppercase all fruits
    upper := mapStrings(fruits, strings.ToUpper)
    fmt.Println("Uppercase:", upper)

    // Filter: only fruits with more than 5 characters
    long := filterStrings(fruits, func(s string) bool {
        return len(s) > 5
    })
    fmt.Println("Long names:", long)
}
```

---

## What's Next?

With functions mastered, let's learn about **pointers** — how Go lets you share and modify data efficiently by passing references instead of copies.
