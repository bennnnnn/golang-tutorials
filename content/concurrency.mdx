---
title: "Concurrency"
description: "Harness Go's goroutines and channels for concurrent programming."
order: 15
difficulty: "advanced"
estimatedMinutes: 25
---

## What is Concurrency?

Concurrency means doing multiple things at the same time. Go was designed with concurrency as a first-class feature — it's one of Go's biggest strengths.

**Real-world examples:**
- A web server handling multiple requests simultaneously
- Downloading several files at once
- Processing data while reading from a database

---

## Goroutines — Lightweight Threads

A goroutine is a lightweight thread managed by Go's runtime. You create one simply by adding `go` before a function call:

```gorun
// goroutines.go
package main

import (
    "fmt"
    "time"
)

func printNumbers(label string) {
    for i := 1; i <= 3; i++ {
        fmt.Printf("%s: %d\n", label, i)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    // Launch two goroutines — they run concurrently!
    go printNumbers("Goroutine A")
    go printNumbers("Goroutine B")

    // Main function must wait, otherwise program exits
    time.Sleep(500 * time.Millisecond)
    fmt.Println("Done!")
}
```

Goroutines are incredibly lightweight — you can run thousands without issues.

---

## Why Not Just Use `time.Sleep`?

Using `time.Sleep` to wait for goroutines is unreliable. You don't know how long they'll take. Go provides better tools: **channels** and **WaitGroups**.

---

## Channels — Communication Between Goroutines

Channels are Go's way to safely pass data between goroutines:

```gorun
// channels-basic.go
package main

import "fmt"

func main() {
    // Create a channel that carries strings
    ch := make(chan string)

    // Launch a goroutine that sends a message
    go func() {
        ch <- "Hello from a goroutine!"
    }()

    // Receive the message (this blocks until one arrives)
    message := <-ch
    fmt.Println(message)
}
```

**Key rules:**
- `ch <- value` sends a value into the channel
- `value := <-ch` receives a value from the channel
- Sends and receives **block** until the other side is ready

---

## Sending and Receiving Multiple Values

```gorun
// channels-multiple.go
package main

import "fmt"

func calculateSquares(numbers []int, results chan<- int) {
    for _, n := range numbers {
        results <- n * n
    }
    close(results) // signal that no more values will be sent
}

func main() {
    numbers := []int{1, 2, 3, 4, 5}
    results := make(chan int)

    go calculateSquares(numbers, results)

    // Receive values until the channel is closed
    fmt.Println("Squares:")
    for square := range results {
        fmt.Println(square)
    }
}
```

---

## Buffered Channels

Regular channels block immediately. Buffered channels have capacity — sends don't block until the buffer is full:

```gorun
// buffered-channels.go
package main

import "fmt"

func main() {
    // Buffered channel with capacity 3
    ch := make(chan string, 3)

    // These sends don't block (buffer has space)
    ch <- "first"
    ch <- "second"
    ch <- "third"
    // ch <- "fourth" would block (buffer full)

    // Receive in order
    fmt.Println(<-ch) // first
    fmt.Println(<-ch) // second
    fmt.Println(<-ch) // third

    fmt.Println("Buffer length demo:")
    ch2 := make(chan int, 5)
    ch2 <- 10
    ch2 <- 20
    fmt.Printf("Length: %d, Capacity: %d\n", len(ch2), cap(ch2))
}
```

---

## Channel Direction

You can restrict channels to be **send-only** or **receive-only** in function parameters. This makes your code safer:

```gorun
// channel-direction.go
package main

import "fmt"

// producer can only SEND to the channel
func producer(out chan<- int) {
    for i := 1; i <= 5; i++ {
        out <- i
    }
    close(out)
}

// consumer can only RECEIVE from the channel
func consumer(in <-chan int) {
    for val := range in {
        fmt.Printf("Received: %d\n", val)
    }
}

func main() {
    ch := make(chan int)

    go producer(ch) // sends values
    consumer(ch)    // receives values
}
```

---

## Select — Waiting on Multiple Channels

`select` lets you wait on multiple channel operations at once. It's like a `switch` for channels:

```gorun
// select.go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    // Two goroutines sending at different speeds
    go func() {
        time.Sleep(100 * time.Millisecond)
        ch1 <- "Fast message"
    }()
    go func() {
        time.Sleep(200 * time.Millisecond)
        ch2 <- "Slow message"
    }()

    // Receive from whichever is ready first
    for i := 0; i < 2; i++ {
        select {
        case msg := <-ch1:
            fmt.Println("Channel 1:", msg)
        case msg := <-ch2:
            fmt.Println("Channel 2:", msg)
        }
    }
}
```

### Select with Timeout

Avoid waiting forever by adding a timeout:

```gorun
// select-timeout.go
package main

import (
    "fmt"
    "time"
)

func slowOperation() chan string {
    ch := make(chan string)
    go func() {
        time.Sleep(2 * time.Second)
        ch <- "operation complete"
    }()
    return ch
}

func main() {
    result := slowOperation()

    select {
    case msg := <-result:
        fmt.Println("Got result:", msg)
    case <-time.After(500 * time.Millisecond):
        fmt.Println("Timed out! Operation took too long.")
    }
}
```

---

## WaitGroups — Waiting for Goroutines to Finish

`sync.WaitGroup` is the proper way to wait for multiple goroutines:

```gorun
// waitgroup.go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done() // signal completion when function returns

    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Duration(id) * 100 * time.Millisecond)
    fmt.Printf("Worker %d done\n", id)
}

func main() {
    var wg sync.WaitGroup

    for i := 1; i <= 5; i++ {
        wg.Add(1)     // increment counter
        go worker(i, &wg)
    }

    wg.Wait() // block until counter reaches zero
    fmt.Println("\nAll workers completed!")
}
```

**Pattern:**
1. `wg.Add(1)` before launching each goroutine
2. `defer wg.Done()` at the start of each goroutine
3. `wg.Wait()` to block until all are done

---

## Mutexes — Protecting Shared Data

When multiple goroutines access the same data, use `sync.Mutex` to prevent race conditions:

```gorun
// mutex.go
package main

import (
    "fmt"
    "sync"
)

type SafeCounter struct {
    mu    sync.Mutex
    count int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()         // lock before accessing
    defer c.mu.Unlock() // unlock when done
    c.count++
}

func (c *SafeCounter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.count
}

func main() {
    counter := &SafeCounter{}
    var wg sync.WaitGroup

    // 1000 goroutines all incrementing the same counter
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }

    wg.Wait()
    fmt.Println("Final count:", counter.Value()) // Always 1000
}
```

Without the mutex, the count would be unpredictable due to race conditions.

---

## Pipeline Pattern

Chain stages of processing together using channels:

```gorun
// pipeline.go
package main

import "fmt"

// Stage 1: Generate numbers
func generate(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

// Stage 2: Square each number
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

// Stage 3: Filter (keep only values > threshold)
func filter(in <-chan int, threshold int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            if n > threshold {
                out <- n
            }
        }
        close(out)
    }()
    return out
}

func main() {
    // Chain: generate -> square -> filter(> 10)
    numbers := generate(1, 2, 3, 4, 5)
    squared := square(numbers)
    filtered := filter(squared, 10)

    fmt.Println("Numbers squared, then filtered (> 10):")
    for result := range filtered {
        fmt.Println(result)
    }
}
```

---

<ChallengeBlock
  title="Concurrent Doubler"
  description="Launch 5 goroutines, each doubling a number (1 through 5). Collect all results through a channel and print them. Use a WaitGroup to wait for all goroutines to finish before closing the channel."
  hint="Create a chan int with a buffer of 5. Launch 5 goroutines, each sending i*2 to the channel. Use sync.WaitGroup — call wg.Add(1) before each goroutine and wg.Done() inside it. After wg.Wait(), close the channel and range over it."
  starter={`package main

import (
\t"fmt"
\t"sync"
)

func main() {
\tvar wg sync.WaitGroup
\tresults := make(chan int, 5)

\tfor i := 1; i <= 5; i++ {
\t\twg.Add(1)
\t\tgo func(n int) {
\t\t\tdefer wg.Done()
\t\t\t// TODO: send n*2 to results channel
\t\t}(i)
\t}

\t// TODO: wait for all goroutines, then close the channel
\twg.Wait()
\tclose(results)

\tfor r := range results {
\t\tfmt.Println(r)
\t}
}`}
/>

## Congratulations!

You've covered the fundamentals of Go — from Hello World to concurrent programming with goroutines, channels, and synchronization.

**You're now ready to:**
- Build web servers with Go's `net/http` package
- Create CLI tools
- Work with databases
- Build microservices

Keep practicing and explore the [Go standard library](https://pkg.go.dev/std) for more tools!
