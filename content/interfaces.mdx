---
title: "Interfaces"
description: "Define behavior in Go with interfaces — implicit implementation, type assertions, and real-world patterns."
order: 12
---

## What is an Interface?

An interface defines a **set of method signatures** — a contract. Any type that has all those methods automatically satisfies the interface. No `implements` keyword needed.

This is Go's secret weapon. Interfaces let you write flexible, testable code without tight coupling.

---

## Defining and Using Interfaces

```gorun
// interface-basic.go
package main

import (
    "fmt"
    "math"
)

// Shape interface — any type with an Area() method is a Shape
type Shape interface {
    Area() float64
}

type Rectangle struct {
    Width, Height float64
}

type Circle struct {
    Radius float64
}

// Rectangle satisfies Shape — it has Area()
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// Circle satisfies Shape — it has Area()
func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

// This function works with ANY Shape
func printArea(s Shape) {
    fmt.Printf("Area: %.2f\n", s.Area())
}

func main() {
    rect := Rectangle{Width: 5, Height: 3}
    circle := Circle{Radius: 4}

    printArea(rect)   // Area: 15.00
    printArea(circle) // Area: 50.27

    // A slice of Shapes — mixing types!
    shapes := []Shape{rect, circle, Rectangle{2, 2}}
    for _, s := range shapes {
        fmt.Printf("%T → %.2f\n", s, s.Area())
    }
}
```

The key insight: `Rectangle` and `Circle` never said "I implement Shape". They just have an `Area()` method, so Go automatically recognizes them as Shapes.

---

## Interfaces with Multiple Methods

Interfaces can require several methods:

```gorun
// multi-method-interface.go
package main

import (
    "fmt"
    "math"
    "strings"
)

type Shape interface {
    Area() float64
    Perimeter() float64
    String() string
}

type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64      { return r.Width * r.Height }
func (r Rectangle) Perimeter() float64 { return 2 * (r.Width + r.Height) }
func (r Rectangle) String() string {
    return fmt.Sprintf("Rectangle(%.1f x %.1f)", r.Width, r.Height)
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64      { return math.Pi * c.Radius * c.Radius }
func (c Circle) Perimeter() float64 { return 2 * math.Pi * c.Radius }
func (c Circle) String() string {
    return fmt.Sprintf("Circle(r=%.1f)", c.Radius)
}

func describe(s Shape) {
    fmt.Printf("%s: area=%.2f, perimeter=%.2f\n",
        s.String(), s.Area(), s.Perimeter())
}

func main() {
    shapes := []Shape{
        Rectangle{5, 3},
        Circle{4},
        Rectangle{2, 2},
    }

    sep := strings.Repeat("-", 45)
    fmt.Println(sep)
    for _, s := range shapes {
        describe(s)
    }
    fmt.Println(sep)
}
```

---

## The Empty Interface — `any`

The empty interface `interface{}` (or its alias `any` in modern Go) has **no methods** — so every type satisfies it. Use it when you need to work with values of unknown type:

```gorun
// empty-interface.go
package main

import "fmt"

// Accepts any type whatsoever
func printAnything(v any) {
    fmt.Printf("value=%v, type=%T\n", v, v)
}

func main() {
    printAnything(42)
    printAnything("hello")
    printAnything(true)
    printAnything([]int{1, 2, 3})

    // Slice of mixed types
    mixed := []any{1, "two", 3.0, true, nil}
    for _, v := range mixed {
        fmt.Printf("%v (%T)\n", v, v)
    }
}
```

> **Tip:** Avoid `any` when you can — it bypasses Go's type safety. Use it only when the type truly isn't known at compile time (like in JSON decoding or generic utilities).

---

## Type Assertions

A type assertion extracts the concrete type from an interface value. Use `value.(Type)`:

```gorun
// type-assertion.go
package main

import "fmt"

func main() {
    var i any = "hello"

    // Type assertion — panics if wrong type
    s := i.(string)
    fmt.Println("String:", s, "length:", len(s))

    // Safe assertion — uses ok pattern (never panics)
    n, ok := i.(int)
    fmt.Printf("Is int? %t, value=%d\n", ok, n) // false, 0

    s2, ok := i.(string)
    fmt.Printf("Is string? %t, value=%s\n", ok, s2) // true, hello

    // Common pattern: check before using
    var val any = 42
    if num, ok := val.(int); ok {
        fmt.Println("Got an int:", num*2)
    }
}
```

Always use the `value, ok := i.(Type)` form to avoid panics in production code.

---

## Type Switch

A type switch checks the dynamic type of an interface value across multiple cases — much cleaner than chained type assertions:

```gorun
// type-switch.go
package main

import "fmt"

func describe(i any) string {
    switch v := i.(type) {
    case int:
        return fmt.Sprintf("int: %d (doubled: %d)", v, v*2)
    case string:
        return fmt.Sprintf("string: %q (length: %d)", v, len(v))
    case bool:
        return fmt.Sprintf("bool: %t", v)
    case []int:
        return fmt.Sprintf("[]int with %d elements: %v", len(v), v)
    case nil:
        return "nil value"
    default:
        return fmt.Sprintf("unknown type: %T", v)
    }
}

func main() {
    values := []any{42, "hello", true, []int{1, 2, 3}, nil, 3.14}
    for _, v := range values {
        fmt.Println(describe(v))
    }
}
```

---

## Composing Interfaces

Interfaces can be composed from other interfaces:

```gorun
// interface-composition.go
package main

import "fmt"

type Reader interface {
    Read() string
}

type Writer interface {
    Write(s string)
}

// ReadWriter composes both
type ReadWriter interface {
    Reader
    Writer
}

type Buffer struct {
    data string
}

func (b *Buffer) Read() string    { return b.data }
func (b *Buffer) Write(s string)  { b.data += s }

func readFrom(r Reader) {
    fmt.Println("Read:", r.Read())
}

func writeTo(w Writer, s string) {
    w.Write(s)
}

func main() {
    buf := &Buffer{}

    // Buffer satisfies Reader, Writer, AND ReadWriter
    writeTo(buf, "Hello, ")
    writeTo(buf, "World!")
    readFrom(buf) // Read: Hello, World!

    var rw ReadWriter = buf
    rw.Write(" More data.")
    fmt.Println("Final:", rw.Read())
}
```

---

## Real-World Pattern: Dependency Injection

Interfaces shine for testing — swap out real implementations with fakes:

```gorun
// interface-di.go
package main

import "fmt"

// Interface for sending notifications
type Notifier interface {
    Send(to, message string) error
}

// Real email implementation (would use SMTP in production)
type EmailNotifier struct {
    From string
}

func (e EmailNotifier) Send(to, message string) error {
    fmt.Printf("[EMAIL] From: %s → To: %s: %s\n", e.From, to, message)
    return nil
}

// Fake for testing
type LogNotifier struct {
    Logs []string
}

func (l *LogNotifier) Send(to, message string) error {
    entry := fmt.Sprintf("To: %s | %s", to, message)
    l.Logs = append(l.Logs, entry)
    return nil
}

// This function works with ANY Notifier
func sendWelcome(n Notifier, userEmail string) {
    err := n.Send(userEmail, "Welcome to Go Tutorials!")
    if err != nil {
        fmt.Println("Failed to send:", err)
    }
}

func main() {
    // Production use
    email := EmailNotifier{From: "noreply@example.com"}
    sendWelcome(email, "alice@example.com")

    // Test use — no real email sent
    logger := &LogNotifier{}
    sendWelcome(logger, "bob@example.com")
    fmt.Println("Logged:", logger.Logs)
}
```

---

<ChallengeBlock
  title="Shape Interface"
  description="Define a Shape interface with two methods: Area() float64 and Perimeter() float64. Then implement it for Circle (using radius) and Square (using side length). Print the area and perimeter of each."
  hint="Use math.Pi for the circle: Area = π × r², Perimeter = 2 × π × r. For a square: Area = side², Perimeter = 4 × side. Import 'math'."
  starter={`package main

import (
\t"fmt"
\t"math"
)

type Shape interface {
\t// TODO: declare Area() and Perimeter() methods
}

type Circle struct {
\tRadius float64
}

type Square struct {
\tSide float64
}

// TODO: implement Shape for Circle and Square

func printShape(s Shape) {
\tfmt.Printf("Area: %.2f, Perimeter: %.2f\n", s.Area(), s.Perimeter())
}

func main() {
\tc := Circle{Radius: 5}
\tsq := Square{Side: 4}
\tprintShape(c)
\tprintShape(sq)
\t_ = math.Pi // remove when implemented
}`}
/>

## What's Next?

Interfaces are central to writing flexible Go code. Next, let's tackle **error handling** — Go's explicit, reliable approach to dealing with things that go wrong.
