---
title: "HTTP in Go"
description: "Work with HTTP handler functions, URL parsing, status codes, and query parameters using Go's net/http and net/url packages."
order: 17
difficulty: "intermediate"
estimatedMinutes: 20
---

## Go's HTTP Standard Library

Go's `net/http` package is one of the most complete HTTP implementations in any language's standard library. You can build production-grade web servers, clients, and middleware without installing any third-party framework.

**What `net/http` gives you:**
- HTTP server with routing, middleware, and TLS
- HTTP client for making requests
- Request/response types with full header, body, and cookie support
- Testing utilities (`httptest.NewRecorder`)

**What `net/url` gives you:**
- URL parsing and construction
- Query parameter encoding/decoding
- Path resolution

---

## HTTP Handler Functions

An **HTTP handler** is any value with a `ServeHTTP(w http.ResponseWriter, r *http.Request)` method — or equivalently, an `http.HandlerFunc` which is just a function with the right signature. Handlers read the request and write the response.

```gorun
// handler-concept.go
package main

import (
    "fmt"
    "net/http"
    "net/http/httptest"
    "strings"
)

// greetHandler writes a personalised greeting
func greetHandler(w http.ResponseWriter, r *http.Request) {
    name := r.URL.Query().Get("name")
    if name == "" {
        name = "World"
    }
    fmt.Fprintf(w, "Hello, %s!", name)
}

func main() {
    // httptest.NewRecorder captures what the handler writes
    req, _ := http.NewRequest("GET", "/greet?name=Gopher", nil)
    rec := httptest.NewRecorder()

    greetHandler(rec, req)

    fmt.Println("Status:", rec.Code)
    fmt.Println("Body:", rec.Body.String())
    fmt.Println("Contains Hello:", strings.Contains(rec.Body.String(), "Hello"))
}
```

`httptest.NewRecorder()` is the same tool the Go standard library itself uses for testing handlers — you get a real response writer that captures status codes, headers, and body.

---

## URL Parsing

`net/url.Parse` breaks a URL string into its components: scheme, host, path, query, and fragment. This is essential when building APIs that construct or inspect URLs programmatically.

```gorun
// url-parsing.go
package main

import (
    "fmt"
    "net/url"
)

func main() {
    raw := "https://api.example.com:8080/v1/users?page=2&limit=10#results"
    u, err := url.Parse(raw)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }

    fmt.Println("Scheme: ", u.Scheme)
    fmt.Println("Host:   ", u.Host)
    fmt.Println("Path:   ", u.Path)
    fmt.Println("Query:  ", u.RawQuery)
    fmt.Println("Fragment:", u.Fragment)

    // Access individual query parameters
    params := u.Query()
    fmt.Println("page:  ", params.Get("page"))
    fmt.Println("limit: ", params.Get("limit"))
}
```

---

## HTTP Status Codes

`net/http` defines constants for every HTTP status code. Using named constants instead of raw numbers makes code self-documenting and prevents typos.

```gorun
// status-codes.go
package main

import (
    "fmt"
    "net/http"
    "net/http/httptest"
)

func resourceHandler(w http.ResponseWriter, r *http.Request) {
    id := r.URL.Query().Get("id")

    switch id {
    case "":
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprint(w, "missing id parameter")
    case "secret":
        w.WriteHeader(http.StatusForbidden)
        fmt.Fprint(w, "access denied")
    case "ghost":
        w.WriteHeader(http.StatusNotFound)
        fmt.Fprint(w, "resource not found")
    default:
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, "resource %s loaded", id)
    }
}

func check(id string) {
    req, _ := http.NewRequest("GET", "/?id="+id, nil)
    rec := httptest.NewRecorder()
    resourceHandler(rec, req)
    fmt.Printf("id=%q  status=%d  body=%q\n", id, rec.Code, rec.Body.String())
}

func main() {
    fmt.Println("Common HTTP status codes:")
    fmt.Printf("  StatusOK           = %d\n", http.StatusOK)
    fmt.Printf("  StatusBadRequest   = %d\n", http.StatusBadRequest)
    fmt.Printf("  StatusForbidden    = %d\n", http.StatusForbidden)
    fmt.Printf("  StatusNotFound     = %d\n", http.StatusNotFound)
    fmt.Println()
    check("")
    check("secret")
    check("ghost")
    check("42")
}
```

---

## Query Parameters

Query parameters (the `?key=value&key2=value2` part of a URL) are the primary way HTTP GET requests pass data. Go gives you `r.URL.Query()` which returns a `url.Values` map.

```gorun
// query-params.go
package main

import (
    "fmt"
    "net/http"
    "net/http/httptest"
    "strconv"
)

func searchHandler(w http.ResponseWriter, r *http.Request) {
    q := r.URL.Query()

    query := q.Get("q")           // single value
    tags := q["tag"]              // multi-value: ?tag=go&tag=web
    pageStr := q.Get("page")

    page, err := strconv.Atoi(pageStr)
    if err != nil || page < 1 {
        page = 1
    }

    fmt.Fprintf(w, "query=%q tags=%v page=%d", query, tags, page)
}

func main() {
    url := "/search?q=goroutines&tag=go&tag=concurrency&page=3"
    req, _ := http.NewRequest("GET", url, nil)
    rec := httptest.NewRecorder()

    searchHandler(rec, req)
    fmt.Println(rec.Body.String())
}
```

---

## Building URLs with url.Values

Instead of manually concatenating `?key=value` strings (error-prone with special characters), use `url.Values` to build query strings safely. It handles URL-encoding automatically.

```gorun
// build-url.go
package main

import (
    "fmt"
    "net/url"
)

func buildAPIURL(base, path string, params map[string]string) string {
    u, _ := url.Parse(base)
    u.Path = path

    q := url.Values{}
    for k, v := range params {
        q.Set(k, v)
    }
    u.RawQuery = q.Encode()

    return u.String()
}

func main() {
    // url.Values handles encoding for you
    v := url.Values{}
    v.Set("search", "hello world") // space becomes +
    v.Set("lang", "go")
    v.Add("tag", "web")
    v.Add("tag", "api") // multiple values for same key
    fmt.Println("Encoded:", v.Encode())

    // Build a full URL
    apiURL := buildAPIURL(
        "https://api.example.com",
        "/v2/search",
        map[string]string{
            "q":    "concurrency",
            "page": "1",
        },
    )
    fmt.Println("API URL:", apiURL)
}
```

---

<ChallengeBlock
  title="Write an HTTP Handler with Validation"
  description="Write an HTTP handler function called divideHandler that reads two query parameters, 'a' and 'b', converts them to integers, and writes the result of a/b to the response. If either parameter is missing or not a number, write status 400. If b is 0, write status 400 with 'division by zero'. Test it with httptest.NewRecorder for a valid case (a=10, b=2) and print the status code and body."
  hint="Use strconv.Atoi to parse the parameters. Call w.WriteHeader(http.StatusBadRequest) before fmt.Fprint(w, ...) when there is an error. For the happy path, use fmt.Fprintf(w, '%d', result)."
  starter={`package main

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"strconv"
)

func divideHandler(w http.ResponseWriter, r *http.Request) {
	aStr := r.URL.Query().Get("a")
	bStr := r.URL.Query().Get("b")

	// TODO: parse aStr and bStr as integers; return 400 on error
	_, _ = strconv.Atoi(aStr)
	_, _ = strconv.Atoi(bStr)

	// TODO: return 400 if b is 0, otherwise write the result
}

func main() {
	req, _ := http.NewRequest("GET", "/divide?a=10&b=2", nil)
	rec := httptest.NewRecorder()
	// TODO: call divideHandler and print the status code and body
	_ = req
	_ = rec
}`}
/>

## What's Next?

You can now write and test HTTP handlers, parse URLs, use status code constants, and build query strings safely. Next up: **JSON encoding and decoding** — the language HTTP APIs speak.
