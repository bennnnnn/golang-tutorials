---
title: "Packages & Modules"
description: "Organize your Go code into packages, manage dependencies with modules, and use the standard library."
order: 14
---

## What are Packages?

Every Go file starts with a `package` declaration. A **package** is a collection of `.go` files in the same directory that share the same package name. Packages let you:

- **Organize** related code together
- **Reuse** code across your project
- **Control visibility** — what's exported vs private

---

## Exported vs Unexported Identifiers

Go uses a simple rule for visibility: **capitalized names are exported (public), lowercase names are unexported (private)**.

```gorun
// exported-vs-unexported.go
package main

import "fmt"

// Exported — starts with uppercase, visible to other packages
type User struct {
    Name  string // exported field
    Email string // exported field
    age   int    // unexported field — only this package can use it
}

// Exported function
func NewUser(name, email string, age int) User {
    return User{Name: name, Email: email, age: age}
}

// Unexported helper — only usable within this package
func validate(email string) bool {
    return len(email) > 0
}

func main() {
    u := NewUser("Alice", "alice@example.com", 30)
    fmt.Println("Name:", u.Name)
    fmt.Println("Email:", u.Email)
    // fmt.Println(u.age) // Would fail in another package — unexported

    fmt.Println("Valid email:", validate(u.Email))
}
```

**Naming convention:**
- `User`, `NewUser`, `ParseJSON` → exported (visible everywhere)
- `user`, `newUser`, `parseJSON` → unexported (package-private)

---

## Go Modules — Project Management

A **module** is a collection of packages with a `go.mod` file. It tracks your project's name and dependencies. Every Go project starts with:

```bash
go mod init your-module-name
```

This creates `go.mod`:

```text
module your-module-name

go 1.22
```

The module name is used in import paths. For a GitHub project it would be something like `github.com/alice/myapp`.

---

## Organizing Code into Packages

Here's a typical project structure:

```text
myapp/
├── go.mod
├── main.go           ← package main (entry point)
├── math/
│   └── math.go       ← package math
└── greet/
    └── greet.go      ← package greet
```

Example `math/math.go`:
```go
package math

// Add adds two numbers. Exported — starts with uppercase.
func Add(a, b int) int {
    return a + b
}

// helper is unexported — only usable within the math package
func helper(n int) int {
    return n * 2
}
```

Example `main.go`:
```go
package main

import (
    "fmt"
    "myapp/math"  // import using module name + path
)

func main() {
    fmt.Println(math.Add(3, 4)) // 7
}
```

---

## The Standard Library

Go ships with a rich standard library. You never need to install these — they're built in:

```gorun
// standard-library.go
package main

import (
    "fmt"
    "math"
    "math/rand"
    "sort"
    "strings"
    "strconv"
    "time"
)

func main() {
    // strings — string manipulation
    fmt.Println(strings.ToUpper("hello"))           // HELLO
    fmt.Println(strings.Split("a,b,c", ","))        // [a b c]
    fmt.Println(strings.Contains("golang", "lang")) // true
    fmt.Println(strings.TrimSpace("  hi  "))        // hi

    // strconv — type conversions
    n, _ := strconv.Atoi("42")     // string → int
    s := strconv.Itoa(100)         // int → string
    fmt.Println(n, s)              // 42 100

    // math — mathematical functions
    fmt.Printf("Sqrt(16) = %.0f\n", math.Sqrt(16))  // 4
    fmt.Printf("Abs(-5) = %.0f\n", math.Abs(-5))    // 5
    fmt.Printf("Max = %.0f\n", math.Max(3, 7))       // 7

    // sort — sorting slices
    nums := []int{5, 2, 8, 1, 9}
    sort.Ints(nums)
    fmt.Println("Sorted:", nums) // [1 2 5 8 9]

    // time — date and time
    now := time.Now()
    fmt.Println("Year:", now.Year())
    fmt.Println("Formatted:", now.Format("2006-01-02"))

    // rand — random numbers
    r := rand.New(rand.NewSource(42))
    fmt.Println("Random:", r.Intn(100)) // random int 0-99
}
```

**Essential standard library packages:**

| Package | Purpose |
|---------|---------|
| `fmt` | Printing and formatting |
| `strings` | String manipulation |
| `strconv` | Type conversions |
| `math` | Math functions |
| `sort` | Sorting |
| `time` | Dates and timers |
| `os` | File system, env vars, exit |
| `io` | Input/output interfaces |
| `net/http` | HTTP server and client |
| `encoding/json` | JSON encode/decode |
| `sync` | Goroutine synchronization |
| `errors` | Error creation and wrapping |
| `log` | Structured logging |

---

## Using Third-Party Packages

Fetch external packages with `go get`:

```bash
# Download and add to go.mod
go get github.com/some/package

# Download a specific version
go get github.com/some/package@v1.2.3
```

After running `go get`, the package appears in `go.mod` and `go.sum`:

```text
module myapp

go 1.22

require (
    github.com/some/package v1.2.3
)
```

Then import and use it normally:

```go
import "github.com/some/package"
```

---

## Important `go` Commands

```gorun
// go-commands.go
package main

import "fmt"

func main() {
    commands := []struct {
        cmd  string
        desc string
    }{
        {"go mod init <name>", "Create a new module"},
        {"go get <package>", "Download and add a dependency"},
        {"go mod tidy", "Remove unused deps, add missing ones"},
        {"go run main.go", "Compile and run"},
        {"go build", "Compile to a binary"},
        {"go test ./...", "Run all tests"},
        {"go fmt ./...", "Format all code"},
        {"go vet ./...", "Check for common mistakes"},
        {"go doc <package>", "View package documentation"},
    }

    fmt.Printf("%-25s %s\n", "Command", "Purpose")
    fmt.Println(fmt.Sprintf("%s", "--------------------------------------------"))
    for _, c := range commands {
        fmt.Printf("%-25s %s\n", c.cmd, c.desc)
    }
}
```

---

## Multiple Files in One Package

All `.go` files in the same directory share the same package. They can see each other's unexported names:

```gorun
// multi-file-package.go
package main

import "fmt"

// Imagine this is split across multiple files in the same package:

// --- types.go ---
type Config struct {
    Host string
    Port int
}

// --- defaults.go ---
func defaultConfig() Config {
    return Config{Host: "localhost", Port: 8080}
}

// --- server.go ---
func startServer(cfg Config) string {
    return fmt.Sprintf("Server running at %s:%d", cfg.Host, cfg.Port)
}

// --- main.go ---
func main() {
    cfg := defaultConfig()
    fmt.Println(startServer(cfg))

    // Override
    cfg.Port = 9090
    fmt.Println(startServer(cfg))
}
```

---

## The `init()` Function

Each package can have an `init()` function that runs automatically before `main()`. Used for one-time setup:

```gorun
// init-function.go
package main

import "fmt"

var config map[string]string

func init() {
    // Runs automatically before main()
    config = map[string]string{
        "host": "localhost",
        "port": "8080",
        "env":  "development",
    }
    fmt.Println("[init] Configuration loaded")
}

func main() {
    fmt.Println("[main] Starting app...")
    fmt.Printf("Host: %s, Port: %s, Env: %s\n",
        config["host"], config["port"], config["env"])
}
```

> **Rules:** A package can have multiple `init()` functions (even across multiple files). They run in the order they appear, after all variable declarations are initialized.

---

<ChallengeBlock
  title="Mini Math Package"
  description="The code below simulates having a 'math helper' package inline. Implement the three functions: Max, Min, and Abs. Each takes two or one float64 values respectively. Then call each in main and print the results."
  hint="Max returns the larger of two values, Min the smaller. Abs returns the absolute value (if n < 0, return -n)."
  starter={`package main

import "fmt"

// Pretend these are in a separate package

func Max(a, b float64) float64 {
\t// TODO: return the larger value
\treturn 0
}

func Min(a, b float64) float64 {
\t// TODO: return the smaller value
\treturn 0
}

func Abs(n float64) float64 {
\t// TODO: return the absolute value
\treturn 0
}

func main() {
\tfmt.Println("Max(3, 7):", Max(3, 7))   // 7
\tfmt.Println("Min(3, 7):", Min(3, 7))   // 3
\tfmt.Println("Abs(-5.5):", Abs(-5.5))   // 5.5
}`}
/>

## What's Next?

You now know how to structure real Go projects. The final topic is the one that makes Go special — **concurrency** with goroutines, channels, and WaitGroups.
