---
title: "Error Handling"
description: "Handle errors the Go way — the error type, if err != nil, custom errors, wrapping, and panic/recover."
order: 13
---

## Go's Error Philosophy

Go treats errors as **normal values**, not exceptions. A function that can fail returns an `error` as its last return value. The caller checks it explicitly. No hidden exceptions, no surprise crashes.

This might feel verbose at first, but it forces you to think about failure at every step — which leads to more robust programs.

---

## The `error` Type

`error` is a built-in interface with a single method:

```go
type error interface {
    Error() string
}
```

Any type with an `Error() string` method is an error. Most of the time, you'll use the standard library to create errors.

---

## The `if err != nil` Pattern

This is the most common Go pattern. Every function that can fail returns `(result, error)`:

```gorun
// if-err-nil.go
package main

import (
    "errors"
    "fmt"
    "strconv"
)

func parseInt(s string) (int, error) {
    n, err := strconv.Atoi(s)
    if err != nil {
        return 0, err // pass the error up
    }
    return n, nil // nil means "no error"
}

func main() {
    // Success case
    n, err := parseInt("42")
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("Parsed:", n) // 42
    }

    // Failure case
    n, err = parseInt("abc")
    if err != nil {
        fmt.Println("Error:", err) // strconv.Atoi: parsing "abc": invalid syntax
    }

    // Multiple checks in sequence
    a, err := parseInt("10")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }

    b, err := parseInt("20")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }

    fmt.Println("Sum:", a+b) // 30

    _ = errors.New("") // just to use the import
}
```

---

## Creating Errors

### `errors.New` — Simple Error Messages

```gorun
// errors-new.go
package main

import (
    "errors"
    "fmt"
)

func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func getUser(id int) (string, error) {
    if id <= 0 {
        return "", errors.New("user id must be positive")
    }
    users := map[int]string{1: "Alice", 2: "Bob"}
    user, ok := users[id]
    if !ok {
        return "", errors.New("user not found")
    }
    return user, nil
}

func main() {
    result, err := divide(10, 3)
    if err == nil {
        fmt.Printf("10 / 3 = %.4f\n", result)
    }

    _, err = divide(5, 0)
    fmt.Println("Error:", err)

    user, err := getUser(1)
    if err == nil {
        fmt.Println("User:", user)
    }

    _, err = getUser(99)
    fmt.Println("Error:", err)
}
```

### `fmt.Errorf` — Formatted Error Messages

Use `fmt.Errorf` when you want to include dynamic values in the error message:

```gorun
// fmt-errorf.go
package main

import "fmt"

func openFile(name string) error {
    // Simulate a "file not found" error
    return fmt.Errorf("open %q: no such file or directory", name)
}

func fetchUser(id int) (string, error) {
    if id < 1 {
        return "", fmt.Errorf("invalid user id %d: must be >= 1", id)
    }
    return "Alice", nil
}

func main() {
    err := openFile("config.json")
    fmt.Println(err)

    _, err = fetchUser(-5)
    fmt.Println(err)
}
```

---

## Sentinel Errors — Named Error Values

Sentinel errors are package-level error variables that callers can compare against:

```gorun
// sentinel-errors.go
package main

import (
    "errors"
    "fmt"
)

// Define sentinel errors as package-level variables
var (
    ErrNotFound   = errors.New("not found")
    ErrPermission = errors.New("permission denied")
    ErrInvalidID  = errors.New("invalid id")
)

func findItem(id int) (string, error) {
    if id <= 0 {
        return "", ErrInvalidID
    }
    items := map[int]string{1: "apple", 2: "banana"}
    item, ok := items[id]
    if !ok {
        return "", ErrNotFound
    }
    return item, nil
}

func main() {
    _, err := findItem(-1)
    if errors.Is(err, ErrInvalidID) {
        fmt.Println("Bad request: invalid ID")
    }

    _, err = findItem(99)
    if errors.Is(err, ErrNotFound) {
        fmt.Println("Item not found — show 404")
    }

    item, err := findItem(1)
    if err == nil {
        fmt.Println("Found:", item)
    }
}
```

---

## Custom Error Types

Create a struct that implements the `error` interface to carry extra context:

```gorun
// custom-error-type.go
package main

import "fmt"

// Custom error type with extra fields
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed for %q: %s", e.Field, e.Message)
}

type NotFoundError struct {
    Resource string
    ID       int
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("%s with id %d not found", e.Resource, e.ID)
}

func validateAge(age int) error {
    if age < 0 {
        return &ValidationError{Field: "age", Message: "must be non-negative"}
    }
    if age > 150 {
        return &ValidationError{Field: "age", Message: "unrealistic value"}
    }
    return nil
}

func main() {
    err := validateAge(-5)
    if err != nil {
        fmt.Println("Error:", err)

        // Type assert to access extra fields
        var ve *ValidationError
        if verr, ok := err.(*ValidationError); ok {
            fmt.Println("Field that failed:", verr.Field)
        }
        _ = ve
    }

    err = validateAge(25)
    if err == nil {
        fmt.Println("Age is valid")
    }
}
```

---

## Wrapping Errors with `%w`

Use `%w` in `fmt.Errorf` to wrap an error. Wrapping preserves the original error while adding context — like a stack trace in words:

```gorun
// error-wrapping.go
package main

import (
    "errors"
    "fmt"
)

var ErrNotFound = errors.New("not found")

func readConfig(path string) error {
    // Simulate underlying error
    return ErrNotFound
}

func loadApp(configPath string) error {
    err := readConfig(configPath)
    if err != nil {
        // Wrap the error — adds context while preserving the original
        return fmt.Errorf("loadApp: reading config %q: %w", configPath, err)
    }
    return nil
}

func startServer() error {
    err := loadApp("config.json")
    if err != nil {
        return fmt.Errorf("startServer: %w", err)
    }
    return nil
}

func main() {
    err := startServer()
    if err != nil {
        fmt.Println("Error:", err)
        // Full chain: startServer: loadApp: reading config "config.json": not found

        // errors.Is unwraps the chain to find the root cause
        if errors.Is(err, ErrNotFound) {
            fmt.Println("Root cause: resource not found")
        }
    }
}
```

---

## `errors.Is` and `errors.As`

- **`errors.Is(err, target)`** — checks if any error in the chain matches `target`
- **`errors.As(err, &target)`** — finds the first error in the chain of type `*T`

```gorun
// errors-is-as.go
package main

import (
    "errors"
    "fmt"
)

type DBError struct {
    Code    int
    Message string
}

func (e *DBError) Error() string {
    return fmt.Sprintf("DB error %d: %s", e.Code, e.Message)
}

var ErrTimeout = errors.New("timeout")

func queryDB() error {
    dbErr := &DBError{Code: 500, Message: "connection refused"}
    return fmt.Errorf("queryDB: %w", dbErr)
}

func runWithTimeout() error {
    return fmt.Errorf("operation: %w", ErrTimeout)
}

func main() {
    // errors.Is — check for sentinel error in chain
    err := runWithTimeout()
    if errors.Is(err, ErrTimeout) {
        fmt.Println("Timed out — please retry")
    }

    // errors.As — extract typed error from chain
    err = queryDB()
    var dbErr *DBError
    if errors.As(err, &dbErr) {
        fmt.Printf("DB error code: %d, message: %s\n", dbErr.Code, dbErr.Message)
    }
}
```

---

## Panic and Recover

`panic` stops normal execution and unwinds the stack. `recover` catches a panic inside a deferred function. Use these sparingly — they're for truly unexpected, unrecoverable situations:

```gorun
// panic-recover.go
package main

import "fmt"

// safeDiv recovers from division-by-zero panic
func safeDiv(a, b int) (result int, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("recovered from panic: %v", r)
        }
    }()
    return a / b, nil
}

func mustPositive(n int) int {
    if n <= 0 {
        panic(fmt.Sprintf("expected positive number, got %d", n))
    }
    return n
}

func main() {
    result, err := safeDiv(10, 2)
    if err == nil {
        fmt.Println("10 / 2 =", result)
    }

    result, err = safeDiv(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
    }

    // panic without recover — DON'T do this in production without wrapping
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Caught panic:", r)
        }
    }()

    mustPositive(-1) // will panic, caught by defer above
}
```

> **Rule of thumb:** Return `error` for expected failures. Use `panic` only for programmer errors (like a nil pointer passed where one is never expected) or truly unrecoverable states.

---

<ChallengeBlock
  title="Safe Divide"
  description="Write a safeDivide(a, b float64) (float64, error) function that returns an error when b is zero instead of panicking. Test it with both a valid division and a division by zero."
  hint="Use fmt.Errorf to create the error message. When b is zero, return 0 and the error. When b is not zero, return a/b and nil."
  starter={`package main

import (
\t"fmt"
)

func safeDivide(a, b float64) (float64, error) {
\t// TODO: return an error if b is zero, otherwise return a/b
\treturn 0, nil
}

func main() {
\tresult, err := safeDivide(10, 2)
\tif err != nil {
\t\tfmt.Println("Error:", err)
\t} else {
\t\tfmt.Printf("10 / 2 = %.1f\n", result)
\t}

\t_, err = safeDivide(5, 0)
\tif err != nil {
\t\tfmt.Println("Error:", err)
\t}
}`}
/>

## What's Next?

You now handle errors the Go way — explicit, clear, and robust. Next, let's learn about **packages and modules** — how to organize your code and use external libraries.
