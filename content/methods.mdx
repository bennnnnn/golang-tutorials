---
title: "Methods"
description: "Attach functions to types in Go using methods, value receivers, and pointer receivers."
order: 11
---

## What is a Method?

A method is a function **attached to a type**. Instead of writing `area(rect)`, you write `rect.Area()`. Methods give your types behavior — they're how Go achieves object-oriented-like design.

---

## Defining a Method

Add a **receiver** between `func` and the method name. The receiver specifies which type this method belongs to:

```gorun
// define-method.go
package main

import (
    "fmt"
    "math"
)

type Rectangle struct {
    Width, Height float64
}

// Method on Rectangle — receiver is (r Rectangle)
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func main() {
    rect := Rectangle{Width: 5, Height: 3}
    fmt.Printf("Rectangle area: %.2f\n", rect.Area())
    fmt.Printf("Rectangle perimeter: %.2f\n", rect.Perimeter())

    circle := Circle{Radius: 4}
    fmt.Printf("Circle area: %.2f\n", circle.Area())
}
```

The receiver `(r Rectangle)` means "this method belongs to Rectangle, and inside the method body, use `r` to refer to the value."

---

## Value Receivers vs Pointer Receivers

This is one of the most important distinctions in Go:

- **Value receiver** `(r Rectangle)` — works on a **copy**. Can't modify the original.
- **Pointer receiver** `(r *Rectangle)` — works on the **original**. Can modify it.

```gorun
// receivers.go
package main

import "fmt"

type Counter struct {
    count int
}

// Value receiver — reads the value, doesn't modify it
func (c Counter) Value() int {
    return c.count
}

// Pointer receiver — modifies the original
func (c *Counter) Increment() {
    c.count++
}

func (c *Counter) Reset() {
    c.count = 0
}

func main() {
    c := Counter{}

    c.Increment()
    c.Increment()
    c.Increment()
    fmt.Println("Count:", c.Value()) // 3

    c.Reset()
    fmt.Println("After reset:", c.Value()) // 0

    // Go auto-takes the address when needed
    // c.Increment() works even though c is not a pointer
    // Go automatically does (&c).Increment()
}
```

---

## When to Use Pointer Receivers

**Use a pointer receiver when:**
1. The method needs to **modify** the receiver
2. The struct is **large** (avoids expensive copying)
3. **Consistency** — if any method uses a pointer receiver, all should

**Use a value receiver when:**
1. The method only **reads** the value
2. The type is a small, simple type (like a primitive wrapper)

```gorun
// pointer-receiver-example.go
package main

import "fmt"

type BankAccount struct {
    Owner   string
    Balance float64
}

// Pointer receiver — modifies balance
func (a *BankAccount) Deposit(amount float64) {
    if amount > 0 {
        a.Balance += amount
    }
}

// Pointer receiver — modifies balance
func (a *BankAccount) Withdraw(amount float64) bool {
    if amount > a.Balance {
        return false
    }
    a.Balance -= amount
    return true
}

// Value receiver — only reads, no modification
func (a BankAccount) String() string {
    return fmt.Sprintf("Account[%s]: $%.2f", a.Owner, a.Balance)
}

func main() {
    acc := BankAccount{Owner: "Alice", Balance: 1000}

    acc.Deposit(500)
    fmt.Println(acc.String()) // Account[Alice]: $1500.00

    ok := acc.Withdraw(200)
    fmt.Printf("Withdrew $200: %t\n", ok)
    fmt.Println(acc.String()) // Account[Alice]: $1300.00

    ok = acc.Withdraw(2000)
    fmt.Printf("Withdrew $2000: %t\n", ok) // false — insufficient funds
}
```

---

## Methods on Non-Struct Types

You can define methods on **any type you define** — not just structs. You can't add methods to built-in types (`int`, `string`) directly, but you can define a new type based on them:

```gorun
// method-non-struct.go
package main

import (
    "fmt"
    "strings"
)

// Define a new type based on string
type Color string

const (
    Red   Color = "red"
    Green Color = "green"
    Blue  Color = "blue"
)

func (c Color) Upper() Color {
    return Color(strings.ToUpper(string(c)))
}

func (c Color) IsLight() bool {
    return c == Green || c == "yellow" || c == "white"
}

// Define a type based on []string
type StringList []string

func (sl StringList) Join(sep string) string {
    return strings.Join(sl, sep)
}

func (sl StringList) Contains(s string) bool {
    for _, v := range sl {
        if v == s {
            return true
        }
    }
    return false
}

func main() {
    c := Red
    fmt.Println(c.Upper())    // RED
    fmt.Println(c.IsLight())  // false

    list := StringList{"go", "python", "rust"}
    fmt.Println(list.Join(", "))     // go, python, rust
    fmt.Println(list.Contains("go")) // true
}
```

---

## Method Chaining

If methods return the receiver (pointer), you can chain calls:

```gorun
// method-chaining.go
package main

import (
    "fmt"
    "strings"
)

type QueryBuilder struct {
    table      string
    conditions []string
    orderBy    string
    limit      int
}

func (q *QueryBuilder) From(table string) *QueryBuilder {
    q.table = table
    return q
}

func (q *QueryBuilder) Where(condition string) *QueryBuilder {
    q.conditions = append(q.conditions, condition)
    return q
}

func (q *QueryBuilder) OrderBy(field string) *QueryBuilder {
    q.orderBy = field
    return q
}

func (q *QueryBuilder) Limit(n int) *QueryBuilder {
    q.limit = n
    return q
}

func (q *QueryBuilder) Build() string {
    query := "SELECT * FROM " + q.table
    if len(q.conditions) > 0 {
        query += " WHERE " + strings.Join(q.conditions, " AND ")
    }
    if q.orderBy != "" {
        query += " ORDER BY " + q.orderBy
    }
    if q.limit > 0 {
        query += fmt.Sprintf(" LIMIT %d", q.limit)
    }
    return query
}

func main() {
    q := &QueryBuilder{}
    query := q.From("users").
        Where("age > 18").
        Where("active = true").
        OrderBy("name").
        Limit(10).
        Build()

    fmt.Println(query)
}
```

---

## The `Stringer` Interface

If your type has a `String() string` method, `fmt.Println` will use it automatically. This is Go's way to customize how your type prints:

```gorun
// stringer.go
package main

import "fmt"

type Direction int

const (
    North Direction = iota
    South
    East
    West
)

// String makes Direction implement the Stringer interface
func (d Direction) String() string {
    switch d {
    case North:
        return "North"
    case South:
        return "South"
    case East:
        return "East"
    case West:
        return "West"
    default:
        return "Unknown"
    }
}

type Point struct {
    X, Y int
}

func (p Point) String() string {
    return fmt.Sprintf("(%d, %d)", p.X, p.Y)
}

func main() {
    dir := North
    fmt.Println(dir) // North — uses String() automatically!

    p := Point{3, 4}
    fmt.Println(p)                   // (3, 4)
    fmt.Printf("Point: %v\n", p)    // Point: (3, 4)
    fmt.Printf("Point: %s\n", p)    // Point: (3, 4)
}
```

---

<ChallengeBlock
  title="Stringer Method"
  description="Define a Person struct with Name (string) and Age (int) fields. Add a String() string method so that fmt.Println(p) prints something like 'Alice (age 30)' automatically."
  hint="The fmt package checks if a value implements the fmt.Stringer interface (has a String() string method) and calls it automatically during printing."
  starter={`package main

import "fmt"

type Person struct {
\tName string
\tAge  int
}

// TODO: add a String() string method to Person

func main() {
\tp := Person{Name: "Alice", Age: 30}
\tfmt.Println(p) // should print: Alice (age 30)
}`}
/>

## What's Next?

With methods, your types have behavior. Next, let's learn about **interfaces** — how Go defines contracts that any type can fulfill.
